# 🔍 품질 관리 체크리스트

> **4단계 기능 품질 관리 체계**  
> 사용자 입장 → 일반화 → 한계점 → 문제 대처

## 📋 체크리스트 사용법

### 🎯 목적
모든 기능 개발 완료 시 반드시 이 체크리스트를 통해 품질을 검증하여 일관된 품질 기준을 유지합니다.

### 📊 평가 기준
- ✅ **통과**: 기준을 완전히 만족
- ⚠️ **주의**: 개선이 필요하나 배포 가능
- ❌ **실패**: 반드시 수정 후 재검토 필요

---

## ⚙️ 검토 시작 전 준비사항

### 🛠️ 필수 도구 설치
```bash
# .NET 프로젝트용 도구
dotnet tool install --global dotnet-reportgenerator-globaltool
dotnet tool install --global Microsoft.CodeAnalysis.Metrics
dotnet tool install --global dotnet-trace
dotnet tool install --global dotnet-counters

# 코드 품질 분석 도구
dotnet add package Microsoft.CodeAnalysis.Analyzers
dotnet add package SonarAnalyzer.CSharp
```

### 📂 검토 환경 설정
1. **프로젝트 빌드 확인**
   ```bash
   dotnet clean
   dotnet build /warnaserror
   ```

2. **테스트 실행 및 커버리지 측정**
   ```bash
   dotnet test --collect:"XPlat Code Coverage"
   reportgenerator -reports:"**/coverage.cobertura.xml" -targetdir:"coveragereport" -reporttypes:Html
   ```

3. **정적 분석 실행**
   ```bash
   dotnet build /p:RunAnalyzersDuringBuild=true
   ```

### 📋 검토 체크리스트 템플릿 준비
- [ ] 검토 보고서 템플릿 생성
- [ ] 스크린샷 캡처 도구 준비
- [ ] 성능 측정 도구 설정
- [ ] 에러 로그 수집 준비

---

## 🎯 1단계: 사용자 입장 검증

### 🎨 사용성 (Usability)
```
목적: 실제 사용자가 쉽고 편리하게 사용할 수 있는가?

□ 사용자가 기능을 쉽게 이해할 수 있는가?
  - 기능의 목적이 명확한가?
  - 사용 방법이 복잡하지 않은가?
  - 학습 비용이 적절한가?

□ 학습 비용이 적절한가?
  - 첫 사용자도 5분 내에 사용법을 익힐 수 있는가?
  - 도움말이나 가이드가 충분한가?
  - 유사한 기능과 일관성이 있는가?

□ 오류 발생 시 명확한 피드백을 제공하는가?
  - 에러 메시지가 이해하기 쉬운가?
  - 해결 방법을 제시하는가?
  - 사용자가 다음 액션을 알 수 있는가?

□ 접근성 요구사항을 만족하는가?
  - 키보드 탐색이 가능한가?
  - 스크린 리더 지원이 되는가?
  - 색상 대비가 충분한가?
```

#### 🔍 실행 가이드
1. **사용자 시나리오 테스트**
   ```
   - 신규 사용자 관점에서 기능 실행
   - 시작부터 완료까지 소요 시간 측정
   - 각 단계별 사용자 경험 기록
   ```

2. **접근성 검증 도구**
   ```bash
   # 웹 접근성 검사 (웹 프로젝트인 경우)
   npm install -g @axe-core/cli
   axe http://localhost:5000
   
   # 색상 대비 검사
   npm install -g pa11y
   pa11y http://localhost:5000
   ```

3. **사용성 평가 체크**
   - [ ] README.md 따라 5분 내 설치/실행 가능한가?
   - [ ] 에러 발생 시 로그에서 원인 파악 가능한가?
   - [ ] 설정 변경이 직관적인가?

**평가 결과**: [ ✅ / ⚠️ / ❌ ]  
**측정 지표**: 첫 사용 소요시간: ___분, 에러 이해도: ___/10점  
**개선 사항**: ________________

### 📝 명확성 (Clarity)
```
목적: 사용자가 혼동 없이 명확하게 이해할 수 있는가?

□ 기능명이 직관적인가?
  - 기능명만으로 역할을 알 수 있는가?
  - 업계 표준 용어를 사용하는가?
  - 줄임말이나 전문용어를 남용하지 않는가?

□ UI/UX가 일관성 있는가?
  - 전체 시스템과 디자인 언어가 통일되었는가?
  - 비슷한 기능들과 동일한 패턴을 사용하는가?
  - 버튼, 아이콘의 의미가 일관되는가?

□ 에러 메시지가 이해하기 쉬운가?
  - 기술적 용어 대신 사용자 친화적 언어를 사용하는가?
  - 문제 상황을 명확히 설명하는가?
  - 해결 방법을 구체적으로 제시하는가?

□ 도움말/가이드가 충분한가?
  - 주요 기능에 대한 설명이 있는가?
  - 단계별 가이드가 제공되는가?
  - FAQ나 트러블슈팅 가이드가 있는가?
```

**평가 결과**: [ ✅ / ⚠️ / ❌ ]  
**개선 사항**: ________________

### 🎨 직관성 (Intuitiveness)
```
목적: 별도 설명 없이도 자연스럽게 사용할 수 있는가?

□ 첫 사용자도 쉽게 사용할 수 있는가?
  - 메뉴 구조가 논리적인가?
  - 중요한 기능이 눈에 잘 띄는가?
  - 사용자 플로우가 자연스러운가?

□ 업계 표준/관례를 따르는가?
  - 일반적인 UI 패턴을 사용하는가?
  - 사용자가 기대하는 위치에 기능이 있는가?
  - 표준 단축키를 지원하는가?

□ 시각적 단서가 충분한가?
  - 클릭 가능한 요소가 명확한가?
  - 현재 상태를 시각적으로 표시하는가?
  - 로딩, 진행 상태를 표시하는가?

□ 사용자 기대와 일치하는가?
  - 버튼을 누르면 예상한 결과가 나오는가?
  - 데이터 입력 형식이 예측 가능한가?
  - 기능 그룹핑이 논리적인가?
```

**평가 결과**: [ ✅ / ⚠️ / ❌ ]  
**개선 사항**: ________________

### 🔐 권한 (Authorization)
```
목적: 적절한 권한 관리가 이루어지고 있는가?

□ 필요한 권한이 적절히 정의되었는가?
  - 최소 권한 원칙을 준수하는가?
  - 역할별 권한이 명확히 구분되는가?
  - 임시 권한 상승이 필요한 경우가 관리되는가?

□ 권한 상승 프로세스가 명확한가?
  - 권한 요청 절차가 정의되어 있는가?
  - 승인 프로세스가 명확한가?
  - 권한 부여 이력이 기록되는가?

□ 최소 권한 원칙을 준수하는가?
  - 기능 수행에 필요한 최소한의 권한만 요구하는가?
  - 불필요한 관리자 권한을 요구하지 않는가?
  - 권한 범위가 적절히 제한되는가?

□ 권한 오용 방지 대책이 있는가?
  - 권한 남용 모니터링이 가능한가?
  - 의심스러운 권한 사용을 감지하는가?
  - 권한 취소/수정이 즉시 반영되는가?
```

**평가 결과**: [ ✅ / ⚠️ / ❌ ]  
**개선 사항**: ________________

---

## 💻 2A단계: 코드 품질 검증

### 📏 5Line 원칙 준수
```
목적: 함수의 복잡도를 제한하여 가독성과 유지보수성을 향상시킨다

□ 모든 메서드가 5라인 이내인가?
  - 메서드 시그니처 제외하고 실제 로직 5라인 이내
  - 중괄호만 있는 라인은 제외
  - 주석은 라인 수에서 제외

□ 5라인을 초과하는 경우 적절한 분해가 되었는가?
  - 단일 책임 원칙에 따른 메서드 분리
  - 의미 있는 메서드명으로 분해
  - 과도한 파라미터 전달 방지

□ 조건문과 반복문이 적절히 처리되었는가?
  - 중첩된 if문을 Early Return으로 개선
  - 복잡한 조건식을 별도 메서드로 추출
  - LINQ나 함수형 접근으로 반복문 대체
```

#### 🔍 실행 가이드
```bash
# 코드 메트릭 측정
dotnet tool install --global Microsoft.CodeAnalysis.Metrics
metrics --project YourProject.csproj --format json

# 긴 메서드 찾기 (PowerShell)
Get-ChildItem -Path src -Recurse -Filter "*.cs" | ForEach-Object {
    $content = Get-Content $_.FullName
    # 메서드별 라인 수 계산 로직 구현
}

# SonarQube 분석 (복잡도 측정)
dotnet sonarscanner begin /k:"project-key"
dotnet build
dotnet sonarscanner end
```

**평가 결과**: [ ✅ / ⚠️ / ❌ ]  
**측정 지표**: 평균 메서드 길이: ___라인, 5라인 초과 메서드: ___개  
**개선 사항**: ________________

### 🏛️ Clean Architecture 준수
```
목적: 계층 간 의존성 규칙을 준수하여 유지보수 가능한 구조를 유지한다

□ 의존성 방향이 올바른가?
  - Web → Application → Domain
  - Infrastructure → Application
  - Domain은 외부 의존성 없음

□ 각 계층의 책임이 명확한가?
  - Domain: 비즈니스 규칙, 엔티티, 도메인 서비스
  - Application: 애플리케이션 서비스, Use Case
  - Infrastructure: 외부 시스템 연동, 데이터 접근
  - Web: API 컨트롤러, 프레젠테이션 로직

□ 인터페이스 분리 원칙을 준수하는가?
  - Domain에서 인터페이스 정의
  - Infrastructure에서 구현
  - DI를 통한 의존성 주입

□ 순환 참조가 없는가?
  - 계층 간 순환 참조 확인
  - 패키지 간 순환 참조 확인
```

#### 🔍 실행 가이드
```bash
# 의존성 분석
dotnet list package --include-transitive
dotnet tool install --global deptrac
deptrac analyze

# 아키텍처 검증 스크립트
# 프로젝트 참조 관계 확인
dotnet sln list | grep -E "(Domain|Application|Infrastructure|Web)"
```

**평가 결과**: [ ✅ / ⚠️ / ❌ ]  
**측정 지표**: 순환 참조: ___개, 계층 위반: ___개  
**개선 사항**: ________________

### 🧪 테스트 커버리지 확인
```
목적: 높은 품질의 테스트를 통해 코드의 신뢰성을 보장한다

□ 테스트 커버리지가 충분한가?
  - 라인 커버리지 80% 이상
  - 브랜치 커버리지 70% 이상
  - 핵심 비즈니스 로직 100% 커버리지

□ 테스트가 독립적인가?
  - 테스트 간 의존성 없음
  - 실행 순서와 무관하게 동작
  - 외부 상태에 의존하지 않음

□ 테스트가 명확한가?
  - 테스트명이 의도를 명확히 표현
  - AAA 패턴 (Arrange-Act-Assert) 준수
  - 하나의 테스트는 하나의 관심사만 검증
```

#### 🔍 실행 가이드
```bash
# 테스트 커버리지 측정
dotnet test --collect:"XPlat Code Coverage"
reportgenerator -reports:"**/coverage.cobertura.xml" -targetdir:"coveragereport" -reporttypes:Html

# 테스트 품질 체크
dotnet test --logger:trx --collect:"Code Coverage"

# Mutation Testing (선택사항)
dotnet tool install --global dotnet-stryker
dotnet stryker
```

**평가 결과**: [ ✅ / ⚠️ / ❌ ]  
**측정 지표**: 라인 커버리지: ___%,  브랜치 커버리지: ___%  
**개선 사항**: ________________

---

## 🔧 2B단계: 일반화 검증

### ✅ 요구사항 준수
```
목적: 정의된 모든 요구사항이 올바르게 구현되었는가?

□ 모든 기능적 요구사항이 포함되었는가?
  - 기능 명세서의 모든 항목이 구현되었는가?
  - 예외 상황 처리가 포함되었는가?
  - 사용자 시나리오가 모두 지원되는가?

□ 비기능적 요구사항이 고려되었는가?
  - 성능 요구사항을 만족하는가?
  - 보안 요구사항이 구현되었는가?
  - 확장성이 고려되었는가?

□ 법적/규제 요구사항이 반영되었는가?
  - 개인정보보호 규정을 준수하는가?
  - 산업 표준을 따르는가?
  - 컴플라이언스 요구사항이 충족되는가?

□ 비즈니스 규칙이 정확히 구현되었는가?
  - 업무 로직이 정확한가?
  - 데이터 검증 규칙이 적용되었는가?
  - 워크플로우가 올바른가?
```

**평가 결과**: [ ✅ / ⚠️ / ❌ ]  
**개선 사항**: ________________

### ⏳ 지연성 고려 (Lazy Loading, Observer)
```
목적: 성능 최적화와 실시간성이 적절히 고려되었는가?

□ 불필요한 데이터 로딩을 방지하는가?
  - Lazy Loading이 적용되었는가?
  - 페이지네이션이 구현되었는가?
  - 필요한 데이터만 로드하는가?

□ 실시간 업데이트가 필요한 부분이 식별되었는가?
  - Observer 패턴이 적용되었는가?
  - WebSocket이나 Server-Sent Events가 사용되었는가?
  - 실시간 알림이 구현되었는가?

□ 캐싱 전략이 정의되었는가?
  - 적절한 캐시 레벨이 선택되었는가?
  - 캐시 무효화 정책이 있는가?
  - 캐시 히트율이 측정 가능한가?

□ 비동기 처리가 적절히 적용되었는가?
  - 긴 작업이 비동기로 처리되는가?
  - 사용자 피드백이 즉시 제공되는가?
  - 백그라운드 작업이 적절히 관리되는가?
```

**평가 결과**: [ ✅ / ⚠️ / ❌ ]  
**개선 사항**: ________________

### 📊 기준정보 정의
```
목적: 표준화되고 일관된 구조가 유지되는가?

□ 데이터 형식/구조가 표준화되었는가?
  - 공통 데이터 타입이 사용되었는가?
  - 날짜/시간 형식이 통일되었는가?
  - 문자 인코딩이 일관되는가?

□ API 스펙이 명확히 정의되었는가?
  - OpenAPI/Swagger 문서가 있는가?
  - 요청/응답 형식이 명확한가?
  - 버전 관리 정책이 있는가?

□ 에러 코드/메시지가 표준화되었는가?
  - 일관된 에러 코드 체계가 있는가?
  - 에러 메시지 형식이 통일되었는가?
  - 다국어 지원이 고려되었는가?

□ 로깅 형식이 일관성 있는가?
  - 구조화된 로그 형식을 사용하는가?
  - 로그 레벨이 적절히 설정되었는가?
  - 민감 정보가 로그에 포함되지 않는가?
```

**평가 결과**: [ ✅ / ⚠️ / ❌ ]  
**개선 사항**: ________________

### 🔒 권한 신뢰 인증
```
목적: 보안 요소가 충분히 고려되고 구현되었는가?

□ 인증 메커니즘이 안전한가?
  - 강력한 인증 방식이 사용되는가?
  - 다중 인증(MFA)이 지원되는가?
  - 인증 토큰이 안전하게 관리되는가?

□ 세션 관리가 적절한가?
  - 세션 타임아웃이 설정되었는가?
  - 동시 세션 제한이 있는가?
  - 세션 고정 공격이 방지되는가?

□ CSRF, XSS 등 공격에 대한 방어가 있는가?
  - CSRF 토큰이 사용되는가?
  - 입력 데이터가 적절히 검증/이스케이프되는가?
  - Content Security Policy가 설정되었는가?

□ 민감 정보 보호가 충분한가?
  - 패스워드가 안전하게 해싱되는가?
  - 개인정보가 암호화되는가?
  - API 키가 안전하게 관리되는가?
```

**평가 결과**: [ ✅ / ⚠️ / ❌ ]  
**개선 사항**: ________________

### 📈 성능 확인
```
목적: 성능 요구사항이 충족되고 모니터링이 가능한가?

□ 부하 테스트 계획이 수립되었는가?
  - 예상 사용자 수를 기준으로 테스트했는가?
  - 피크 시간 부하를 고려했는가?
  - 장기간 안정성이 검증되었는가?

□ 병목 지점이 식별되었는가?
  - 성능 프로파일링을 수행했는가?
  - 느린 쿼리가 최적화되었는가?
  - 메모리 사용량이 적절한가?

□ 모니터링 지표가 정의되었는가?
  - 응답 시간, 처리량 등이 측정되는가?
  - 에러율이 모니터링되는가?
  - 리소스 사용률이 추적되는가?

□ 성능 최적화 방안이 있는가?
  - 인덱스가 적절히 설정되었는가?
  - 캐싱이 효과적으로 적용되었는가?
  - 불필요한 연산이 최소화되었는가?
```

#### 🔍 실행 가이드
```bash
# 성능 프로파일링
dotnet tool install --global dotnet-trace
dotnet tool install --global dotnet-counters
dotnet tool install --global dotnet-dump

# 기본 성능 측정
dotnet-counters monitor --name YourAppName

# 상세 트레이스 수집
dotnet-trace collect --name YourAppName --output trace.nettrace

# 메모리 덤프 분석
dotnet-dump collect --name YourAppName

# 부하 테스트 (NBomber 사용 예시)
dotnet add package NBomber
# 부하 테스트 스크립트 작성 및 실행

# API 성능 테스트 (k6 사용)
k6 run load-test.js
```

#### 📊 성능 기준 체크리스트
- [ ] API 응답 시간 < 200ms (95 percentile)
- [ ] 메모리 사용량 < 512MB (일반적인 경우)
- [ ] CPU 사용률 < 70% (평균)
- [ ] 동시 사용자 ___명 이상 지원
- [ ] 처리량 ___TPS 이상

**평가 결과**: [ ✅ / ⚠️ / ❌ ]  
**측정 지표**: 응답시간: ___ms, 처리량: ___TPS, 메모리: ___MB  
**개선 사항**: ________________

---

## ⚠️ 3단계: 한계점 분석

### 🛡️ 안정성 & 효율성 (Stress Test)
```
목적: 극한 상황에서도 안정적으로 동작하는가?

□ 최대 부하 상황에서의 동작 검증
  - 최대 동시 사용자 수를 견디는가?
  - 메모리 부족 상황에서 graceful degradation이 가능한가?
  - CPU 사용률이 100%에 도달해도 응답하는가?

□ 메모리 누수 방지
  - 장시간 실행 후에도 메모리 사용량이 안정적인가?
  - 대량 데이터 처리 후 메모리가 해제되는가?
  - 메모리 프로파일링을 통해 누수를 확인했는가?

□ 장애 복구 메커니즘
  - 서비스 장애 시 자동 복구가 가능한가?
  - 데이터베이스 연결 실패 시 재시도 로직이 있는가?
  - Circuit breaker 패턴이 적용되었는가?

□ 데이터 정합성 보장
  - 트랜잭션이 적절히 관리되는가?
  - 동시성 문제가 해결되었는가?
  - 백업/복구 시나리오가 검증되었는가?
```

**평가 결과**: [ ✅ / ⚠️ / ❌ ]  
**최대 처리 한계**: ________________  
**개선 사항**: ________________

### 💻 개발 환경
```
목적: 다양한 환경에서 정상적으로 동작하는가?

□ 다양한 OS 지원
  - Windows, macOS, Linux에서 테스트했는가?
  - OS별 특이사항이 문서화되었는가?
  - 환경변수 설정이 OS별로 가이드되었는가?

□ 브라우저 호환성
  - 주요 브라우저(Chrome, Firefox, Safari, Edge)에서 테스트했는가?
  - 모바일 브라우저에서도 동작하는가?
  - IE 지원이 필요한 경우 확인했는가?

□ 모바일 지원
  - 반응형 디자인이 적용되었는가?
  - 터치 인터페이스가 고려되었는가?
  - 모바일 성능이 최적화되었는가?

□ 레거시 시스템 연동
  - 기존 시스템과 호환되는가?
  - 데이터 마이그레이션이 검증되었는가?
  - API 호환성이 유지되는가?
```

**평가 결과**: [ ✅ / ⚠️ / ❌ ]  
**지원 환경 목록**: ________________  
**개선 사항**: ________________

### 🚫 기능 제한
```
목적: 알려진 제한사항이 명확히 문서화되었는가?

□ 제한사항 1: [구체적인 제한 내용]
  - 제한 이유: ________________
  - 영향 범위: ________________
  - 우회 방법: ________________
  - 향후 개선 계획: ________________

□ 제한사항 2: [구체적인 제한 내용]
  - 제한 이유: ________________
  - 영향 범위: ________________
  - 우회 방법: ________________
  - 향후 개선 계획: ________________

□ 제한사항 3: [구체적인 제한 내용]
  - 제한 이유: ________________
  - 영향 범위: ________________
  - 우회 방법: ________________
  - 향후 개선 계획: ________________
```

**평가 결과**: [ ✅ / ⚠️ / ❌ ]  
**사용자 공지 필요 여부**: [ Y / N ]

---

## 🚨 4단계: 문제 대처 방안

### 📋 에스컬레이션 조건
```
다음 조건 중 하나라도 해당하면 즉시 개발자에게 에스컬레이션

□ 기능 구현 불가능 판단 시
  - 기술적 제약으로 구현이 불가능한 경우
  - 외부 의존성으로 인한 구현 지연
  - 아키텍처 변경이 반드시 필요한 경우

□ 성능 목표 달성 어려움
  - 응답 시간 목표를 50% 이상 초과
  - 메모리 사용량이 예상보다 2배 이상 증가
  - 동시 처리 가능 사용자 수가 목표의 50% 미만

□ 보안 이슈 발견
  - 중대한 보안 취약점 발견
  - 개인정보 유출 위험성 존재
  - 인증/인가 체계에 결함 발견

□ 아키텍처 변경 필요
  - 현재 구조로는 요구사항 충족 불가
  - 확장성 문제로 전면 재설계 필요
  - 외부 시스템 연동에 근본적 문제 존재
```

### 🔄 단계별 해결 프로세스

#### 1차 시도 (2시간 이내)
```
□ 자체 해결 시도
  - 문제 원인 분석
  - 기존 문서/가이드 참조
  - 간단한 해결 방안 시도
  - 시간 기록 및 결과 문서화
```

#### 2차 시도 (1일 이내)
```
□ 팀 내 협의
  - 팀원들과 문제 공유
  - 집단 지성을 통한 해결 방안 모색
  - 유사 사례 검토
  - 해결 방안 합의 및 실행
```

#### 3차 시도 (3일 이내)
```
□ 외부 전문가 자문
  - 관련 분야 전문가에게 자문 요청
  - 온라인 커뮤니티 활용
  - 벤더 기술 지원 요청
  - 컨설팅 서비스 검토
```

#### 에스컬레이션 (즉시)
```
□ 상위 의사결정권자 보고
  - 문제 상황 상세 보고서 작성
  - 시도한 해결 방안들 정리
  - 비즈니스 영향도 분석
  - 대안 제시 및 의사결정 요청
```

## 📊 최종 품질 점수

### 점수 계산
- **1단계 (사용자 입장)**: ___/40점 (각 항목 10점)
- **2A단계 (코드 품질)**: ___/60점 (5Line 20점, Clean Architecture 20점, 테스트 20점)
- **2B단계 (일반화)**: ___/50점 (각 항목 10점)  
- **3단계 (한계점)**: ___/30점 (각 항목 10점)
- **4단계 (문제 대처)**: ___/20점 (각 항목 10점)

**총점**: ___/200점

### 품질 등급
- **S등급 (180-200점)**: 최고 품질, 모범 사례
- **A등급 (160-179점)**: 우수 품질, 출시 권장
- **B등급 (140-159점)**: 양호 품질, 출시 가능
- **C등급 (120-139점)**: 개선 후 출시 권장
- **D등급 (100-119점)**: 상당한 개선 필요
- **F등급 (100점 미만)**: 출시 불가, 전면 재작업 필요

### 🎯 필수 통과 기준
**다음 조건을 모두 만족해야 출시 가능:**
- [ ] 5Line 원칙 준수율 90% 이상
- [ ] Clean Architecture 의존성 규칙 100% 준수
- [ ] 테스트 커버리지 80% 이상
- [ ] 보안 취약점 Critical 0개
- [ ] 성능 요구사항 100% 충족

## 📝 최종 검토 의견

### 강점
- ________________
- ________________
- ________________

### 개선 필요사항
- ________________
- ________________
- ________________

### 권장 사항
- ________________
- ________________
- ________________

---

## 🛠️ 자동화 도구 및 스크립트

### 📜 품질 검증 자동화 스크립트
```powershell
# PowerShell 스크립트: QualityCheck.ps1
param(
    [string]$ProjectPath = ".",
    [string]$OutputPath = "quality-report"
)

Write-Host "🔍 품질 검증 시작..." -ForegroundColor Green

# 1. 빌드 검증
Write-Host "📦 빌드 검증 중..." -ForegroundColor Yellow
dotnet clean $ProjectPath
dotnet build $ProjectPath /warnaserror
if ($LASTEXITCODE -ne 0) {
    Write-Host "❌ 빌드 실패" -ForegroundColor Red
    exit 1
}

# 2. 테스트 실행 및 커버리지
Write-Host "🧪 테스트 및 커버리지 측정 중..." -ForegroundColor Yellow
dotnet test $ProjectPath --collect:"XPlat Code Coverage" --logger:trx
reportgenerator -reports:"**/coverage.cobertura.xml" -targetdir:"$OutputPath/coverage" -reporttypes:Html

# 3. 정적 분석
Write-Host "🔍 정적 분석 실행 중..." -ForegroundColor Yellow
dotnet build $ProjectPath /p:RunAnalyzersDuringBuild=true

# 4. 성능 메트릭
Write-Host "📊 성능 메트릭 수집 중..." -ForegroundColor Yellow
# 여기에 성능 테스트 스크립트 추가

# 5. 5Line 체크
Write-Host "📏 5Line 원칙 검증 중..." -ForegroundColor Yellow
# 메서드 길이 체크 스크립트

Write-Host "✅ 품질 검증 완료!" -ForegroundColor Green
Write-Host "📋 보고서 위치: $OutputPath" -ForegroundColor Cyan
```

### 🔧 개발 환경 설정 스크립트
```bash
#!/bin/bash
# setup-quality-tools.sh

echo "🛠️ 품질 관리 도구 설정 중..."

# 기본 .NET 도구 설치
dotnet tool install --global dotnet-reportgenerator-globaltool
dotnet tool install --global Microsoft.CodeAnalysis.Metrics
dotnet tool install --global dotnet-trace
dotnet tool install --global dotnet-counters
dotnet tool install --global dotnet-dump

# 코드 품질 분석 도구
dotnet tool install --global dotnet-sonarscanner

# Git hooks 설정 (선택사항)
cp quality-hooks/pre-commit .git/hooks/
chmod +x .git/hooks/pre-commit

echo "✅ 도구 설정 완료!"
```

### 📝 검토 보고서 자동 생성
```csharp
// ReportGenerator.cs - 검토 보고서 자동 생성 도구
public class QualityReportGenerator
{
    public void GenerateReport(QualityMetrics metrics)
    {
        var template = File.ReadAllText("quality-report-template.md");
        
        template = template.Replace("{{총점}}", metrics.TotalScore.ToString());
        template = template.Replace("{{등급}}", metrics.Grade);
        template = template.Replace("{{커버리지}}", metrics.Coverage.ToString("P"));
        template = template.Replace("{{5Line준수율}}", metrics.FiveLineCompliance.ToString("P"));
        
        File.WriteAllText($"quality-report-{DateTime.Now:yyyyMMdd}.md", template);
    }
}
```

---

## 📋 검토자를 위한 실행 가이드

### 🚀 검토 시작하기
1. **환경 준비 (최초 1회)**
   ```bash
   # 도구 설치
   ./setup-quality-tools.sh
   
   # 프로젝트 복제 및 의존성 설치
   git clone [project-url]
   cd [project-name]
   dotnet restore
   ```

2. **매 검토 시 실행**
   ```powershell
   # 자동 품질 검증 실행
   .\QualityCheck.ps1 -ProjectPath "." -OutputPath "quality-report"
   
   # 결과 확인
   # - coverage/index.html (커버리지 보고서)
   # - quality-report/ (종합 보고서)
   ```

### 📊 결과 해석 가이드
- **커버리지 80% 미만**: 테스트 추가 필요
- **5Line 위반 메서드**: 리팩토링 우선순위 표시
- **성능 기준 미달**: 최적화 필요 영역 식별
- **아키텍처 위반**: 즉시 수정 필요

### 🎯 자주하는 실수 방지
1. **체크리스트 건너뛰기 금지**
   - 모든 항목을 순서대로 검토
   - 측정 지표를 반드시 기록

2. **자동화 도구 결과 신뢰**
   - 수동 검증보다 도구 결과 우선
   - 도구가 없는 항목만 수동 검토

3. **문서화 필수**
   - 모든 검토 결과를 기록
   - 개선 사항은 구체적으로 작성

---

## 💡 검토 품질 개선 방안

### 📈 검토 효율성 향상
1. **템플릿 활용**
   - 자동 생성된 보고서 템플릿 사용
   - 반복 작업 최소화

2. **체크리스트 개선**
   - 프로젝트별 특화 항목 추가
   - 측정 기준 구체화

3. **도구 연계 강화**
   - CI/CD 파이프라인 연동
   - 자동 알림 시스템 구축

### 🔍 검토 정확도 향상
1. **크로스 체크**
   - 2명 이상의 검토자가 독립적으로 검토
   - 결과 비교 및 차이점 분석

2. **이력 관리**
   - 이전 검토 결과와 비교
   - 개선 트렌드 추적

3. **피드백 수집**
   - 개발팀 피드백 정기 수집
   - 체크리스트 지속 개선

### 📚 지식 축적
1. **베스트 프랙티스 문서화**
   - 우수 사례 수집 및 공유
   - 개선 전후 비교 자료

2. **교육 프로그램**
   - 정기적인 품질 교육
   - 새로운 도구 및 기법 공유

3. **커뮤니티 활동**
   - 외부 컨퍼런스 참석
   - 오픈소스 프로젝트 기여

---

**검토자**: ________________  
**검토일**: ________________  
**소요시간**: ________________  
**사용 도구**: ________________  
**승인 여부**: [ 승인 / 조건부 승인 / 반려 ]  
**다음 검토 예정일**: ________________ 